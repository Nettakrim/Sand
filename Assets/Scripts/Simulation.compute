#pragma kernel CSInit
#pragma kernel CSMain

RWTexture2D<float4> Result;
RWTexture2D<float4> Input;
int2 Size;
int2 PosOffset;

//not sure why:
//https://discussions.unity.com/t/how-do-int-textures-work-in-computeshaders/246832/2
//doesnt work, but casting is fine

float4 encode(uint4 value) {
    return float4(float(value.r)/255.0, float(value.g)/255.0, float(value.b)/255.0, float(value.a)/255.0);
}

uint4 decode(float4 value) {
    return uint4(uint(value.r*255.0), uint(value.g*255.0), uint(value.b*255.0), uint(value.a*255.0));
}

uint4 getPixel(uint2 pos) {
    if (pos.x < asuint(Size.x) && pos.y < asuint(Size.x)) {
        return decode(Input[pos]);
    }
    return uint4(0,0,1,0);
}

void setPixel(uint2 pos, uint4 data) {
    if (pos.x < asuint(Size.x) && pos.y < asuint(Size.y)) {
        Result[pos] = encode(data);
    }
}

void copyPixel(uint2 pos) {
    if (pos.x < asuint(Size.x) && pos.y < asuint(Size.y)) {
        Result[pos] = Input[pos];
    }
}

bool tileFree(uint4 data, uint sand) {
    //0001 wall
    //1000 miner
    //non-0 sand
    //4-7 crossroads with non-0 component data

    return !(data.g > 0 || data.b == 1 || data.b == 8 || (data.b >= 4 && data.b <= 7 && data.a > 0));
}

uint4 updateTile(uint4 data) {
    //miner: increment 3rd-5th bits, if at max count and theres no sand on the miner, create sand and reset count
    if (data.b == 8) {
        if (data.a < 28) data.a += 4;
        else if (data.g == 0) {
            data.a -= 28;
            data.g = data.r;
        }
    }

    //painter: increment 3rd-5th bits, if at max, change sand color and reset count - only do this if sand is on the painter
    if (data.b == 9 && data.g > 0) {
        if (data.a < 28) data.a += 4;
        else {
            data.a -= 28;
            data.g = (data.g & ~28) | (data.a & 28);
        }
    }

    //gate: set a length 64 bool buffer to do implicit or?
    if (data.b == 15) {
        //todo: make it work
    }

    return data;
}

int getTileMovement(uint4 data) {
    //-1 none
    //0  00 right
    //1  01 left
    //2  10 up
    //3  11 down

    //conveyor: movement direction directly corresponds to component data
    //miner: also the same, however it has bits 000-- that need to get masked
    //this is also the case for painter and all filters, since they keep sand moving in the same direction
    if (data.b == 2 || data.b == 8 || data.b == 12 || data.b == 13 || data.b == 14) return data.a&3;

    //splitter: movment is based on direction entered
    if (data.b == 3) {
        //flip 3rd bit - tilemovement is only called for tiles with sand on them, so this should properly
        data.a ^= 4;

        //flip axis (2nd bit) of sand entry
        //conditionally flip direction (1st bit) if 3rd bit is set
        return (data.a ^ (2 + (data.a << 2)))&3;
    }

    //painter only allows sand through if its timer is 0
    if (data.b == 9) {
        return data.a < 4 ? (data.a & 3) : -1;
    }

    //gate: only let through when all of gate id is ready
    if (data.b == 15) {
        //todo: make it work
        return data.a&3;
    }

    return 3;
}

uint4 sandEnteredTile(uint sand, int direction, uint4 data) {
    if (data.b >= 4 && data.b <= 7) {
        if (direction < 2) {
            //if x axis, replace -X bit with positiveness
            data.b = (data.b & ~1) + direction;
            data.g = sand;
        } else {
            //if y axis, replace X- bit with positiveness
            data.b = (data.b & ~2) + (direction&1) << 2;
            data.a = sand;
        }
        return data;
    }

    data.g = sand;

    //splitter: set first 2 bits to movement direction
    //this is also the case for all filters and the gate
    //and for painters
    if (data.b == 3 || data.b >= 12 || data.b == 9) data.a = (data.b & ~3) | direction;

    //bins and shipping points instantly destroy the sand
    if (data.b == 10 || data.b == 11) {
        //todo: make shipping points work (increment a buffer with a length of 24?)
        data.g = 0;
    }

    if (data.b == 12 || data.b == 13 || data.b == 14) {
        //todo: filters need to not act like bins *always*
        data.g = 0;
    }

    return data;
}

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint2 pos = uint2(id.x*3 + PosOffset.x - 1, id.y*3 + PosOffset.y - 1);

    uint2 rightPos = pos+uint2(1, 0);
    uint2 leftPos  = pos-uint2(1, 0);
    uint2 upPos    = pos+uint2(0, 1);
    uint2 downPos  = pos-uint2(0, 1);

    uint4 current = getPixel(pos);

    uint4 right = getPixel(rightPos);
    uint4 left  = getPixel(leftPos);
    uint4 up    = getPixel(upPos);
    uint4 down  = getPixel(downPos);

    //crossroads are calculated seperately
    if (current.b < 4 || current.b > 7) {
        current = updateTile(current);

        if (current.g > 0) {
            int direction = getTileMovement(current);

            if (direction >= 0) {
                uint4 tileInDirection;

                if (direction == 0)      tileInDirection = right;
                else if (direction == 1) tileInDirection = left;
                else if (direction == 2) tileInDirection = up;
                else if (direction == 3) tileInDirection = down;
                else tileInDirection = uint4(0,0,1,0);

                if (tileFree(tileInDirection, current.g)) {
                    tileInDirection = sandEnteredTile(current.g, direction, tileInDirection);
                    current.g = 0;
                }

                if (direction == 0)      right = tileInDirection;
                else if (direction == 1) left  = tileInDirection;
                else if (direction == 2) up    = tileInDirection;
                else if (direction == 3) down  = tileInDirection;
            }
        }
    } else {
        //crossroad simulation

        int directions = current.b&3;
        // 00 - ur
        // 01 - ul
        // 10 - dr
        // 11 - dl

        if (current.g > 0) {
            //x axis
            bool positive = directions&1 == 0;
            uint4 tileInDirection = positive ? right : left;
            if (tileFree(tileInDirection, current.g)) {
                tileInDirection = sandEnteredTile(current.g, positive ? 0 : 1, tileInDirection);
                current.g = 0;
            }
            if (positive) {
                right = tileInDirection;
            } else {
                left = tileInDirection;
            }
        }

        if (current.a > 0) {
            //y axis
            bool positive = directions < 2;
            uint4 tileInDirection = positive ? up : down;
            if (tileFree(tileInDirection, current.a)) {
                tileInDirection = sandEnteredTile(current.a, positive ? 0 : 1, tileInDirection);
                current.a = 0;
            }
            if (positive) {
                up = tileInDirection;
            } else {
                down = tileInDirection;
            }
        }
    }

    copyPixel(uint2(pos.x+uint(1), pos.y+uint(1)));
    copyPixel(uint2(pos.x+uint(1), pos.y-uint(1)));
    copyPixel(uint2(pos.x-uint(1), pos.y+uint(1)));
    copyPixel(uint2(pos.x-uint(1), pos.y-uint(1)));

    setPixel(rightPos, right);
    setPixel(leftPos, left);
    setPixel(upPos, up);
    setPixel(downPos, down);


    setPixel(pos, current);
}

[numthreads(8,8,1)]
void CSInit (uint3 id : SV_DispatchThreadID)
{
    uint ground = 0;
    uint sand = 0;
    uint component = 2;
    uint componentData = 0;

    int x = int(id.x)-128;
    int y = int(id.y)-128;

    if (x >= 0) {
        if (y >= 0) {
            componentData = (x >= y) ? 3 : 0;
        } else {
            componentData = (x >= -y) ? 3 : 1;
        }
    } else {
        if (y >= 0) {
            componentData += (-x > y+1) ? 2 : 0;
        } else {
            componentData += (-x > -y) ? 1 : 2;
        }
    }

    if (y == 0 && x > 10) {
        component = 8;
        componentData = 3;
        ground = (((uint(x)*123)%16)+16)*8;
    }

    //if (id.y%8 == 0) {
    //    sand = ((id.x%16)+16)*8;
    //}

    Result[id.xy] = encode(uint4(ground, sand, component, componentData));
}